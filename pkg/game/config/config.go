// Package config provides a simple preferences system for The Dark Station.
// Settings are stored in ~/.config/DarkStation/settings.ini
package config

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	appName        = "DarkStation"
	settingsFile   = "settings.ini"
	defaultSection = "General"
)

// Config holds application settings
type Config struct {
	// Display settings
	TileSize int `ini:"tile_size"`

	// Internal: path to config file
	configPath string
}

// DefaultConfig returns a Config with default values
func DefaultConfig() *Config {
	return &Config{
		TileSize: 24, // Default tile size
	}
}

// getConfigDir returns the path to the config directory
func getConfigDir() (string, error) {
	// Try XDG_CONFIG_HOME first
	configHome := os.Getenv("XDG_CONFIG_HOME")
	if configHome == "" {
		// Fall back to ~/.config
		home, err := os.UserHomeDir()
		if err != nil {
			return "", fmt.Errorf("could not determine home directory: %w", err)
		}
		configHome = filepath.Join(home, ".config")
	}

	return filepath.Join(configHome, appName), nil
}

// getConfigPath returns the full path to the settings file
func getConfigPath() (string, error) {
	dir, err := getConfigDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(dir, settingsFile), nil
}

// Load loads the configuration from disk
// If the file doesn't exist, returns default config
func Load() (*Config, error) {
	cfg := DefaultConfig()

	configPath, err := getConfigPath()
	if err != nil {
		return cfg, err
	}
	cfg.configPath = configPath

	// Check if file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		// File doesn't exist, return defaults
		return cfg, nil
	}

	// Open and parse the file
	file, err := os.Open(configPath)
	if err != nil {
		return cfg, fmt.Errorf("could not open config file: %w", err)
	}
	defer file.Close()

	// Parse INI format
	scanner := bufio.NewScanner(file)
	currentSection := defaultSection

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, ";") {
			continue
		}

		// Check for section header
		if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
			currentSection = strings.TrimPrefix(strings.TrimSuffix(line, "]"), "[")
			continue
		}

		// Parse key=value
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// Apply settings based on section and key
		if currentSection == "Display" {
			switch key {
			case "tile_size":
				if v, err := strconv.Atoi(value); err == nil {
					cfg.TileSize = v
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return cfg, fmt.Errorf("error reading config file: %w", err)
	}

	return cfg, nil
}

// Save saves the configuration to disk
func (c *Config) Save() error {
	// Ensure config path is set
	if c.configPath == "" {
		configPath, err := getConfigPath()
		if err != nil {
			return err
		}
		c.configPath = configPath
	}

	// Ensure config directory exists
	dir := filepath.Dir(c.configPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("could not create config directory: %w", err)
	}

	// Create/overwrite the file
	file, err := os.Create(c.configPath)
	if err != nil {
		return fmt.Errorf("could not create config file: %w", err)
	}
	defer file.Close()

	// Write INI format
	writer := bufio.NewWriter(file)

	// Header comment
	fmt.Fprintln(writer, "# The Dark Station - Settings")
	fmt.Fprintln(writer, "# This file is automatically generated")
	fmt.Fprintln(writer)

	// Display section
	fmt.Fprintln(writer, "[Display]")
	fmt.Fprintf(writer, "tile_size = %d\n", c.TileSize)
	fmt.Fprintln(writer)

	return writer.Flush()
}

// SetTileSize sets the tile size and saves the config
func (c *Config) SetTileSize(size int) error {
	c.TileSize = size
	return c.Save()
}

// Global config instance
var current *Config

// Current returns the current global config, loading it if necessary
func Current() *Config {
	if current == nil {
		var err error
		current, err = Load()
		if err != nil {
			// Log error but continue with defaults
			fmt.Fprintf(os.Stderr, "Warning: could not load config: %v\n", err)
			current = DefaultConfig()
		}
	}
	return current
}

// SetCurrent sets the global config instance
func SetCurrent(cfg *Config) {
	current = cfg
}
